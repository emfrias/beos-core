/**
 *  @file
 *  @copyright defined in eos/LICENSE.txt
 */
#pragma once

#include <eosiolib/asset.hpp>
#include <eosiolib/eosio.hpp>
#include <eosiolib/singleton.hpp>
#include <eosiolib/time.hpp>
#include <eosiolib/privileged.hpp>
#include <beoslib/beos_privileged.hpp>
#include <eosio.gateway/eosio.gateway.hpp>

namespace eosio {

   struct distribution_parameters
   {
      uint32_t starting_block;
      uint32_t next_block;
      uint32_t ending_block;
      uint32_t block_interval;
      uint64_t trustee_reward;

      EOSLIB_SERIALIZE( distribution_parameters,
         (starting_block)
         (next_block)
         (ending_block)
         (block_interval)
         (trustee_reward) )
   };

   struct distrib_global_state
   {
      distribution_parameters beos;
      distribution_parameters ram;
      std::vector<asset> proxy_assets;
      uint64_t ram_leftover;

      EOSLIB_SERIALIZE( distrib_global_state, (beos)(ram)(proxy_assets)(ram_leftover) )
   };

   typedef eosio::singleton<N(distribstate), distrib_global_state> distrib_global_state_singleton;

   class distribution : public contract {

      private:

         distrib_global_state            _gstate;
         distrib_global_state_singleton  _global;

         void check( const distribution_parameters& state, uint32_t current_block ) {
            //distribution must be wholly in the future or in the past (to effectively disable it)
            eosio_assert( state.starting_block > current_block || state.ending_block < current_block,
               "Starting block already passed" );
            eosio_assert( state.ending_block >= state.starting_block, "Distribution period must not be empty" );
            eosio_assert( state.block_interval > 0, "Distribution block interval must be positive value" );
            eosio_assert( state.starting_block == state.next_block, "Distribution should start in starting block" );
         }

         void check( const distrib_global_state& state ) {
            uint32_t block_no = get_blockchain_block_number();
            check( state.beos, block_no );
            check( state.ram, block_no );
            if (state.ram_leftover > 0) {
               int64_t distrib_ram_bytes, distrib_net_weight, distrib_cpu_weight;
               get_resource_limits( _self, &distrib_ram_bytes, &distrib_net_weight, &distrib_cpu_weight );
               eosio_assert( static_cast<uint64_t>(distrib_ram_bytes) > state.ram_leftover, "Cannot request to leave more than allocated ram" );
            }
         }

         distrib_global_state get_default_parameters() {
            distrib_global_state dp;

            /*
               STARTING_BLOCK_FOR_BEOS_DISTRIBUTION
               This is the block where the blockchain begins awarding staked BEOS to accounts holding proxyBTS.
               Set this to 7 days worth of blocks.
            */
            dp.beos.starting_block = ${STARTING_BLOCK_FOR_BEOS_DISTRIBUTION};
            dp.beos.next_block = dp.beos.starting_block;

            /*
               ENDING_BLOCK_FOR_BEOS_DISTRIBUTION
               This is the block where the blockchain stops awarding staked BEOS to accounts holding proxyBTS.
               Set this to STARTING_BLOCK_FOR_DISTRIBUTION + 98 days worth of blocks
               (in other words, distribution will last for 98 days/14 weeks).
          
               IMPORTANT NOTE: Staked BEOS will only be “unstakeable” after this period is over.
            */
            dp.beos.ending_block = ${ENDING_BLOCK_FOR_BEOS_DISTRIBUTION};

            dp.beos.block_interval = ${DISTRIBUTION_PAYMENT_BLOCK_INTERVAL_FOR_BEOS_DISTRIBUTION};

            /*
               TRUSTEE_REWARD_BEOS
               This is the total (later remaining) amount of staked BEOS to be awarded to trustee account over
               the BEOS distribution period. All the rest is to be distributed to other accounts holding proxyBTS.
               Set this to 2/7 of total initial supply of BEOS
            */
            dp.beos.trustee_reward = ${TRUSTEE_REWARD_BEOS};

            /*
               STARTING_BLOCK_FOR_RAM_DISTRIBUTION
               This is the block where the blockchain begins awarding RAM to accounts holding proxyBTS.
               Set this to 7 days worth of blocks.
            */
            dp.ram.starting_block = ${STARTING_BLOCK_FOR_RAM_DISTRIBUTION};
            dp.ram.next_block = dp.ram.starting_block;

            /*
               ENDING_BLOCK_FOR_RAM_DISTRIBUTION
               This is the block where the blockchain stops awarding RAM to accounts holding proxyBTS.
               Set this to STARTING_BLOCK_FOR_RAM_DISTRIBUTION  + 280 days worth of blocks
               (in other words, distribution will last for 280 days/40 weeks).

               IMPORTANT NOTE: RAM cannot be sold until after distribution period is over, but it can be spent on
               fees for actions. This prevents a market from forming for RAM until the end of the distribution period.
               This means that anyone needing RAM during distribution period must lock up BTS to get it.
            */
            dp.ram.ending_block = ${ENDING_BLOCK_FOR_RAM_DISTRIBUTION};

            dp.ram.block_interval = ${DISTRIBUTION_PAYMENT_BLOCK_INTERVAL_FOR_RAM_DISTRIBUTION};

            /*
               TRUSTEE_REWARD_RAM
               This is the total (later remaining) amount of RAM to be awarded to trustee account over
               the RAM distribution period. All the rest is to be distributed to other accounts holding
               proxyBTS.
               Set this to 0 (trustee account will have minimal amount of RAM)
            */
            dp.ram.trustee_reward = ${TRUSTEE_REWARD_RAM};

            /*
               Proxy assets that will be base for user weights for distribution.
               Only add such assets here even if there is more (f.e. PXEOS does not participate).
            */
            dp.proxy_assets.emplace_back( 0, S( ${PXBTS_ASSET_PRECISION}, ${PXBTS_ASSET_NAME} ) );
            dp.proxy_assets.emplace_back( 0, S( ${PXBRNP_ASSET_PRECISION}, ${PXBRNP_ASSET_NAME} ) );

            /*
               DISTRIB_RAM_LEFTOVER
               Distribution process will leave all used RAM on beos.distrib account or as much as this parameter
               whichever is greater value. Mostly to be used for stabilizing RAM reward tests, with 0 for mainnet.
            */
            dp.ram_leftover = ${DISTRIB_RAM_LEFTOVER};

            check( dp );
            return dp;
         }

         void calculate_current_reward( uint64_t* to_distribute, uint64_t* to_distribute_trustee,
            uint32_t block_nr, const distribution_parameters& params );

      public:

         distribution( account_name self ) : contract( self ),
            _global( _self, _self )
         {
            if (_global.exists())
               _gstate = _global.get();
            else {
               _gstate = get_default_parameters();
               _global.set(_gstate, _self);
            }
         }

         ~distribution() {}

         void onblock( uint32_t block_nr );
         void changeparams( distrib_global_state new_params );
         void storeparams(uint32_t dummy);

         inline distrib_global_state get_global_state() const {
            return _gstate;
         }

         /// current block is inside [ starting_block : ending_block ] for BEOS distribution
         inline bool is_active_beos_distribution_period() const;
         inline bool is_within_beos_distribution_period( uint32_t block_nr ) const;

         /// current block is above ending_block for BEOS distribution
         inline bool is_past_beos_distribution_period() const;
         inline bool is_past_beos_distribution_period( uint32_t block_nr ) const;

         /// current block is inside [ starting_block : ending_block ] for RAM distribution
         inline bool is_active_ram_distribution_period() const;
         inline bool is_within_ram_distribution_period( uint32_t block_nr ) const;

         /// current block is above ending_block for RAM distribution
         inline bool is_past_ram_distribution_period() const;
         inline bool is_past_ram_distribution_period( uint32_t block_nr ) const;
   };

   inline bool distribution::is_active_beos_distribution_period() const {
      auto block_nr = get_blockchain_block_number();
      return is_within_beos_distribution_period(block_nr);
   }
   
   inline bool distribution::is_within_beos_distribution_period( uint32_t block_nr ) const {
      return _gstate.beos.starting_block <= block_nr && block_nr <= _gstate.beos.ending_block;
   }

   inline bool distribution::is_past_beos_distribution_period() const {
      auto block_nr = get_blockchain_block_number();
      return is_past_beos_distribution_period(block_nr);
   }
   
   inline bool distribution::is_past_beos_distribution_period( uint32_t block_nr ) const {
      return _gstate.beos.ending_block < block_nr;
   }

   inline bool distribution::is_active_ram_distribution_period() const {
      auto block_nr = get_blockchain_block_number();
      return is_within_ram_distribution_period(block_nr);
   }

   inline bool distribution::is_within_ram_distribution_period( uint32_t block_nr ) const {
      return _gstate.ram.starting_block <= block_nr && block_nr <= _gstate.ram.ending_block;
   }

   inline bool distribution::is_past_ram_distribution_period() const {
      auto block_nr = get_blockchain_block_number();
      return is_past_ram_distribution_period(block_nr);
   }

   inline bool distribution::is_past_ram_distribution_period( uint32_t block_nr ) const {
      return _gstate.ram.ending_block < block_nr;
   }

} /// namespace eosio
